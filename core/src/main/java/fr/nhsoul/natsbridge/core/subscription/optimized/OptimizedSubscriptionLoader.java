package fr.nhsoul.natsbridge.core.subscription.optimized;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import fr.nhsoul.natsbridge.core.subscription.SubscriptionHandler;
import fr.nhsoul.natsbridge.core.subscription.SubscriptionRegistry;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;

/**
 * Optimized subscription loader that reads the JSON index generated by the annotation processor.
 * <p>
 * This loader provides significant performance improvements over runtime scanning by:
 * </p>
 * <ul>
 *   <li>Reading pre-compiled subscription information from JSON</li>
 *   <li>Avoiding expensive reflection-based class scanning</li>
 *   <li>Using targeted reflection only for registered methods</li>
 *   <li>Supporting fast startup and initialization</li>
 * </ul>
 *
 * <h2>Performance Characteristics</h2>
 * <ul>
 *   <li>O(1) lookup for subscription information</li>
 *   <li>Minimal reflection overhead (only for registered methods)</li>
 *   <li>Fast JSON parsing with Gson</li>
 *   <li>Memory efficient with lazy loading</li>
 * </ul>
 */
public class OptimizedSubscriptionLoader {

    private static final Logger logger = LoggerFactory.getLogger(OptimizedSubscriptionLoader.class);
    private static final String SUBSCRIPTIONS_FILE = "META-INF/natsbridge/subscriptions.json";

    private final Gson gson = new Gson();
    private final SubscriptionRegistry subscriptionRegistry;

    /**
     * Creates a new OptimizedSubscriptionLoader.
     *
     * @param subscriptionRegistry the subscription registry to populate
     */
    public OptimizedSubscriptionLoader(@NotNull SubscriptionRegistry subscriptionRegistry) {
        this.subscriptionRegistry = subscriptionRegistry;
    }

    /**
     * Loads subscriptions from the generated JSON index.
     *
     * @param pluginRegistry a map of plugin classes to their instances
     * @return the number of subscriptions loaded
     */
    public int loadSubscriptions(@NotNull Map<Class<?>, Object> pluginRegistry) {
        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(SUBSCRIPTIONS_FILE);
        
        if (inputStream == null) {
            logger.debug("No optimized subscriptions index found at {}", SUBSCRIPTIONS_FILE);
            return 0;
        }

        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {
            
            // Parse JSON
            List<SubscriptionInfo> subscriptions = gson.fromJson(reader, 
                new TypeToken<List<SubscriptionInfo>>() {}.getType());
            
            if (subscriptions == null || subscriptions.isEmpty()) {
                logger.debug("Empty or invalid subscriptions index");
                return 0;
            }

            int loadedCount = 0;
            for (SubscriptionInfo info : subscriptions) {
                try {
                    if (loadSubscription(info, pluginRegistry)) {
                        loadedCount++;
                    }
                } catch (Exception e) {
                    logger.error("Failed to load subscription for {}.{}", 
                                info.className, info.methodName, e);
                }
            }

            logger.info("Loaded {} optimized subscriptions from index", loadedCount);
            return loadedCount;

        } catch (IOException e) {
            logger.error("Failed to read subscriptions index", e);
            return 0;
        }
    }

    /**
     * Checks if the optimized subscriptions index exists.
     *
     * @return true if the index exists, false otherwise
     */
    public boolean hasOptimizedIndex() {
        return getClass().getClassLoader().getResource(SUBSCRIPTIONS_FILE) != null;
    }

    /**
     * Loads a single subscription from the index.
     *
     * @param info the subscription information
     * @param pluginRegistry the plugin registry
     * @return true if successfully loaded, false otherwise
     */
    private boolean loadSubscription(@NotNull SubscriptionInfo info, 
                                   @NotNull Map<Class<?>, Object> pluginRegistry) {
        try {
            // Find plugin instance
            Class<?> clazz = Class.forName(info.className);
            Object pluginInstance = pluginRegistry.get(clazz);

            if (pluginInstance == null) {
                logger.warn("No plugin instance found for class: {}", info.className);
                return false;
            }

            // Find method with correct parameter type
            Method method = findMethod(clazz, info.methodName, info.paramType);
            if (method == null) {
                logger.warn("Method {} with parameter type {} not found in class {}", 
                            info.methodName, info.paramType, info.className);
                return false;
            }

            // Register subscription
            subscriptionRegistry.registerMethodSubscription(
                pluginInstance, method, info.subject, info.async
            );

            logger.debug("Loaded optimized subscription: {}.{} -> {}", 
                        info.className, info.methodName, info.subject);
            
            return true;

        } catch (ClassNotFoundException e) {
            logger.warn("Class not found: {}", info.className, e);
            return false;
        } catch (Exception e) {
            logger.error("Error loading subscription {}.{}", info.className, info.methodName, e);
            return false;
        }
    }

    /**
     * Finds a method with the specified name and parameter type.
     *
     * @param clazz the class to search
     * @param methodName the method name
     * @param paramType the parameter type name
     * @return the Method object, or null if not found
     */
    private Method findMethod(@NotNull Class<?> clazz, @NotNull String methodName, @NotNull String paramType) {
        try {
            // Try exact match first
            if ("byte[]".equals(paramType)) {
                return clazz.getMethod(methodName, byte[].class);
            } else if ("java.lang.String".equals(paramType)) {
                return clazz.getMethod(methodName, String.class);
            } else {
                // Try to find by name
                Class<?> paramClass = Class.forName(paramType);
                return clazz.getMethod(methodName, paramClass);
            }
        } catch (NoSuchMethodException e) {
            logger.debug("Method {} not found with expected signature in class {}", 
                        methodName, clazz.getName());
            return null;
        } catch (ClassNotFoundException e) {
            logger.debug("Parameter type class not found: {}", paramType);
            return null;
        }
    }

    /**
     * Represents a subscription entry from the JSON index.
     */
    private static class SubscriptionInfo {
        String className;
        String methodName;
        String paramType;
        String subject;
        boolean async;
    }
}