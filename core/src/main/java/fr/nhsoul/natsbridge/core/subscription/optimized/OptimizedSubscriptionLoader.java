package fr.nhsoul.natsbridge.core.subscription.optimized;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import fr.nhsoul.natsbridge.core.subscription.SubscriptionManager;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;

/**
 * Optimized subscription loader that reads the JSON index generated by the
 * annotation processor.
 */
public class OptimizedSubscriptionLoader {

    private static final Logger logger = LoggerFactory.getLogger(OptimizedSubscriptionLoader.class);
    private static final String SUBSCRIPTIONS_FILE = "META-INF/natsbridge/subscriptions.json";

    private final Gson gson = new Gson();
    private final SubscriptionManager subscriptionManager;

    public OptimizedSubscriptionLoader(@NotNull SubscriptionManager subscriptionManager) {
        this.subscriptionManager = subscriptionManager;
    }

    /**
     * Loads subscriptions from the generated JSON index.
     *
     * @param pluginRegistry a map of plugin classes to their instances
     * @return the number of subscriptions loaded
     */
    public int loadSubscriptions(@NotNull Map<Class<?>, Object> pluginRegistry) {
        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(SUBSCRIPTIONS_FILE);

        if (inputStream == null) {
            logger.debug("No optimized subscriptions index found at {}", SUBSCRIPTIONS_FILE);
            return 0;
        }

        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {

            // Parse JSON
            List<SubscriptionInfo> subscriptions = gson.fromJson(reader,
                    new TypeToken<List<SubscriptionInfo>>() {
                    }.getType());

            if (subscriptions == null || subscriptions.isEmpty()) {
                logger.debug("Empty or invalid subscriptions index");
                return 0;
            }

            int loadedCount = 0;
            for (SubscriptionInfo info : subscriptions) {
                try {
                    if (loadSubscription(info, pluginRegistry)) {
                        loadedCount++;
                    }
                } catch (Exception e) {
                    logger.error("Failed to load subscription for {}.{}",
                            info.className, info.methodName, e);
                }
            }

            logger.info("Loaded {} optimized subscriptions from index", loadedCount);
            return loadedCount;

        } catch (IOException e) {
            logger.error("Failed to read subscriptions index", e);
            return 0;
        }
    }

    public boolean hasOptimizedIndex() {
        return getClass().getClassLoader().getResource(SUBSCRIPTIONS_FILE) != null;
    }

    private boolean loadSubscription(@NotNull SubscriptionInfo info,
            @NotNull Map<Class<?>, Object> pluginRegistry) {
        try {
            // Find plugin instance
            Class<?> clazz = Class.forName(info.className);
            Object pluginInstance = pluginRegistry.get(clazz);

            if (pluginInstance == null) {
                logger.warn("No plugin instance found for class: {}", info.className);
                return false;
            }

            // Find method with correct parameter type
            Method method = findMethod(clazz, info.methodName, info.paramType);
            if (method == null) {
                logger.warn("Method {} with parameter type {} not found in class {}",
                        info.methodName, info.paramType, info.className);
                return false;
            }

            // Register subscription
            subscriptionManager.registerSubscription(
                    pluginInstance, method, info.subject, info.async);

            logger.debug("Loaded optimized subscription: {}.{} -> {}",
                    info.className, info.methodName, info.subject);

            return true;

        } catch (ClassNotFoundException e) {
            logger.warn("Class not found: {}", info.className, e);
            return false;
        } catch (Exception e) {
            logger.error("Error loading subscription {}.{}", info.className, info.methodName, e);
            return false;
        }
    }

    private Method findMethod(@NotNull Class<?> clazz, @NotNull String methodName, @NotNull String paramType) {
        try {
            // Try exact match first
            if ("byte[]".equals(paramType)) {
                return clazz.getMethod(methodName, byte[].class);
            } else if ("java.lang.String".equals(paramType)) {
                return clazz.getMethod(methodName, String.class);
            } else {
                // Try to find by name
                Class<?> paramClass = Class.forName(paramType);
                return clazz.getMethod(methodName, paramClass);
            }
        } catch (NoSuchMethodException e) {
            logger.debug("Method {} not found with expected signature in class {}",
                    methodName, clazz.getName());
            return null;
        } catch (ClassNotFoundException e) {
            logger.debug("Parameter type class not found: {}", paramType);
            return null;
        }
    }

    private static class SubscriptionInfo {
        String className;
        String methodName;
        String paramType;
        String subject;
        boolean async;
    }
}